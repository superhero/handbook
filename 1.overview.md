# Superhero Tool Chain

###### Version 4

---

## Purpose of the Tool Chain

The **Superhero Tool Chain** is a modular, event-driven Node.js tool chain designed to build scalable and maintainable systems. Realeased version 4 introduces a refined stack built focused on component isolation, offering a robust backbone solution that can be used as an event hub or message queue in a choreographed **Eventflow** system.

- The tool chain consists of packages under the `@superhero/*` namespace.
- A strict, documented structure - promoting clarity, repeatability, and automation.
- Communication between systems using secure and distributed event driven solutions.

The tool chain is specifically focused on offering **load distribution** through an **eventual consistency** model that is well-suited for backend services in a microservice orchestration.

---

## Architectural Direction

The **Superhero Tool Chain** is designed to align to defined standards inspired by **Domain-Driven Design** principles, and other well -defined/-known architectural principles. 

The intent is to provide a spectrum of smaller and larger library components, framework and standards that help developers and teams to implement an observable process design using a seamless built-in **load distribution** model.

The architecture promoted by the standards on this page is centered around component isolation, logical and leveled boundaries with an expected dependency direction.

---

## Versioning Strategy

Every package in the tool chain follows a **semantic versioning** model (`MAJOR.MINOR.PATCH`). Versionâ€¯4 introduces `MAJOR` breaking changes from previous generations and establishes a fresh baseline:

- All v4 packages are `>= 4.0.0`.
- Deprecated v3 components (e.g. Eventsource, Redis integration) have been replaced or removed.
- Each v4 package includes a `README.md` and a test-suite for further specifications and clarification.

Packages are updated independently, but respects a structural contract and the architectural boundaries. Internal dependencies must be minimized; each component is designed according to the **composition over abstraction** policy.

### Stability and Update Expectations

When breaking changes or new functionalities are introduced, then they are expected to be relased with `MINOR` version changes.
`PATCH` releases are expected to preserve backward compatibility.
